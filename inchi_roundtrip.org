# name:   inchi_roundtrip.org
# author: nbehrnd@yahoo.com
# date:   <2022-01-29 Sat>
# edit:   <2022-02-18 Fri>

* background/intent

  Since a reply to Jmol's user list by January 14, 2022 ([[https://sourceforge.net/p/jmol/mailman/message/37417385/][reference]]), the program
  extended working with InChI, e.g. to identify molecules as tautomers.  By
  January 20th, 2022, Robert Hanson mentioned interest to venture out a
  structure regeneration ([[https://sourceforge.net/p/inchi/mailman/message/37594623/][reference]]).

  Own experience suggests the use of the optional /fixed H-layer/ should be
  used, i.e., departing from the standard InChI the reference executable
  (version 1.05) However, does the (perhaps implicit) round trip .sdf -> InChI
  -> .sdf retain information about atom connectivity and stereo isomers?  Are
  there structure motifs generally unsuitable for this cycle?

  Apparently, the connectivity table in a .sdf is accessed to assign SMILES
  strings to obtain a reduced representation of the structure.  It is assumed
  SMILES may serve as a reliable monitor to describe a structure prior and after
  this round trip; which equally are known to discern tautomers (e.g., 2-hydroxy
  pyridine, ~Oc1ccccn1~, and its tautoisomer 2-pyridone, ~C1=CC=CNC(=O)1~).  In
  this context, a round trip would be lossless if the SMILES strings about one
  compound would match each other.

* Tools at disposition

  + [[https://openmolecules.org/datawarrior/index.html][DataWarrior]] (version 5.5.0): to generate a library of random molecules,
    assignment of initial SMILES, export of an initial list.
  + Python (version 3.9.9), Openbabel (version 3.1.1), RDKit
    (version 2021.09.2): generation of initial .sdf files from DataWarrior's
    SMILES, conversion of the SMILES into canonical SMILES (OpenBabel form),
    assignment of canonical SMILES after the round trip.  Used as provided by
    Linux Debian 12/bookworm (branch testing).
  + ~inchi-1~ reference executable for Linux (version 1.05) as provided by InChI
    trust  Assignment of InChI, generation of .sdf from the InChI.
  + Jmol (14.32.22, released by 2022-02-15) able to assign SMILES and InChI
    locally, regenerate structures from InChI by relay to the NIH cactus server.
  + Emacs (version 27.1) and orgmode for documentation, build and tangle of the
    eventually used Python script.

  This repository includes scripts for Python 3 newly written and tangled from
  the main file of this project, ~inchi_roundtrip.org~:
  + ~smiles_obsdf.py~ departs from a list of SMILES strings OpenBabel rewrites
    as /canonical SMILES/.  Calling OpenBabel, the structures are converted into
    an intermediate ~.sdf~ submitted to InChI trust's reference executable to
    assign an InChI string.  The InChI string is used by InChI trust's reference
    executable to generate a secondary ~.sdf~ OpenBabel assigns a secondary
    SMILES string.  In Linux, ensure InChI trust's reference executable has the
    executable bit (e.g., by ~chmod u+x ./inchi-1~).

    Here, the round trip is successful if the canonical SMILES string prior the
    round trip matches the canonical SMILES string after the round trip.

    As a control of the approach in script ~smiles_obsdf.py~, test script
    ~test_smiles_obsdf.py~ for Pytest was written.

  + ~inchi_sdf.py~ departs from a list of one or multiple molecules deposit as
    individual models in a ~.sdf~ file.  For each entry, InChI trust's reference
    executable assigns a primary InChI string which is used to write an
    intermediate ~.sdf~ to assign a secondary InChI string.  Thus, the round
    trip only depends on modules of Python's standard library and InChI trusts's
    reference executable.  In Linux, ensure InChI trust's reference executable
    has the executable bit (e.g., by ~chmod u+x ./inchi-1~).

    The round trip is successful if the entry's primary and secondary InChI
    string match each other.

    To check the implementation of ~inchi_sdf.py~, test script
    ~test_inchi_sdf.py~ for Pytest was written.

  + ~smiles_rdkit.py~ departs from a list of SMILES to to write a RDKit SMILES
    string (primary SMILES) to generate individual .sdf (with RDKit).  InChI
    trust's reference executable assigns the InChI string which subsequently is
    used to regenerate a .sdf for which again RDKit assigns a secondary SMILES
    string.

    The round trip is successful if RDKit's primary and secondary SMILES strings
    match each other.

    To check the implementation in ~smiles_rdkit.py~, test script
    ~test_smiles_rdkit.py~ for Pytest was written.

* exploration on the CLI

  This round trip edit stays on the CLI.  It is a prototype with a structure not
  prone to tautomerism.
  
** generation of a reference data set

   + generation of a primary .sdf from the CLI

     #+begin_src bash :tangle no
obabel -:"COC" -h --gen3d --addtotitle "dimethyl ether" -O dimethyl_ether.sdf
     #+end_src

     #+RESULTS:

   + assignment of an InChI

     #+begin_src bash :tangle no :exports both :results code verbatim
./inchi-1 dimethyl_ether.sdf

rm dimethyl_ether.sdf.log
rm dimethyl_ether.sdf.prb 

head dimethyl_ether.sdf.txt
     #+end_src

     #+RESULTS:
     #+begin_src bash
     ,* Input_File: "dimethyl_ether.sdf"
     Structure: 1
     InChI=1S/C2H6O/c1-3-2/h1-2H3
     AuxInfo=1/0/N:1,3,2/E:(1,2)/rA:9nCOCHHHHHH/rB:s1;s2;s1;s1;s1;s3;s3;s3;/rC:.9402,.0576,.0628;2.3612,.0723,.0835;2.8589,.8414,1.1701;.6141,-.5453,-.7889;.5486,1.0724,-.0566;.5486,-.3923,.9802;3.9514,.8181,1.1372;2.5285,.4165,2.1229;2.5285,1.8812,1.0862;
     #+end_src

     #+RESULTS:

** Retrieve a structure .sdf from InChI

   + carve out the InChI:

     #+begin_src bash :tangle no :exports both :results code verbatim 
cat dimethyl_ether.sdf.txt | head -3 | tail -1
cat dimethyl_ether.sdf.txt | head -3 | tail -1 > temp.txt
     #+end_src

     #+RESULTS:
     #+begin_src bash
     InChI=1S/C2H6O/c1-3-2/h1-2H3
     #+end_src

     #+RESULTS:

   + generate InChI's aux format, regenerate a .sdf

     #+begin_src bash :tangle no :exports both :results code verbatim
./inchi-1 -InChI2Struct temp.txt intermediate.txt
head intermediate.txt

echo ""
ls inter*.txt

echo ""
./inchi-1 -OutputSDF intermediate.txt output.sdf

rm intermediate.txt.log intermediate.txt.prb 
head output.sdf 
     #+end_src

     #+RESULTS:
     #+begin_src bash
     ,* Input_File: "temp.txt"
     Structure: 1. (No struct name)
     InChI=1S/C2H6O/c1-3-2/h1-2H3
     AuxInfo=1/0/N:1,2,3/E:(1,2)/rA:3CCO/rB:;s1s2;/rC:;;;

     intermediate.txt

     Structure: 1
     Structure #1. 
       InChIV10                                     

       3  2  0  0  0  0  0  0  0  0  1 V2000
         0.0000    0.0000    0.0000 C   0  0  0     0  0  0  0  0  0
         0.0000    0.0000    0.0000 C   0  0  0     0  0  0  0  0  0
         0.0000    0.0000    0.0000 O   0  0  0     0  0  0  0  0  0
       1  3  1  0  0  0  0
       2  3  1  0  0  0  0
     #+end_src

   + trim the .sdf file

     Compared to the expected pattern of .sdf, there is one heading line to many
     (cf. bug report sent by <2021-10-25 Mon>)

     #+begin_src bash :tangle no :exports both :results code verbatim
cat output.sdf | tail --lines +2
cat output.sdf | tail --lines +2 > check.sdf

echo ""
echo "SMILES assigned on the regenerated .sdf:"
obabel check.sdf -osmi
     #+end_src

     #+RESULTS:
     #+begin_src bash
     Structure #1. 
       InChIV10                                     

       3  2  0  0  0  0  0  0  0  0  1 V2000
         0.0000    0.0000    0.0000 C   0  0  0     0  0  0  0  0  0
         0.0000    0.0000    0.0000 C   0  0  0     0  0  0  0  0  0
         0.0000    0.0000    0.0000 O   0  0  0     0  0  0  0  0  0
       1  3  1  0  0  0  0
       2  3  1  0  0  0  0
     M  END
     $$$$

     SMILES assigned on the regenerated .sdf:
     COC	Structure #1.
     #+end_src

   With the SMILES about the regenerated structure obtained, the round trip .sdf
   -> InChI -> .sdf is complete.  Initial SMILES and SMILES about the
   regenerated structure match each other.

* Programmatic approach, first generation


  This section aims to join the individual steps into a portable script.
  Eventually, a large number of structures are to be submitted to this round
  trip edit.

** still missing parts

   + given a SMILES string, generate a .sdf with OpenBabel

     #+begin_src python :tangle no :output both :results output replace
from openbabel import pybel

mol = pybel.readstring("smi", "CCl")
mol.make3D()
print(mol.write("sdf"))

with open("test_file_ob.sdf", mode="w") as newfile:
    newfile.write(mol.write("sdf"))
     #+end_src

     #+RESULTS:
     #+begin_example

      OpenBabel01302220013D

       5  4  0  0  0  0  0  0  0  0999 V2000
         0.9519    0.0593   -0.0623 C   0  0  0  0  0  0  0  0  0  0  0  0
         2.7188    0.0593   -0.0623 Cl  0  0  0  0  0  0  0  0  0  0  0  0
         0.5948    1.0541   -0.3379 H   0  0  0  0  0  0  0  0  0  0  0  0
         0.5948   -0.1994    0.9369 H   0  0  0  0  0  0  0  0  0  0  0  0
         0.5948   -0.6767   -0.7860 H   0  0  0  0  0  0  0  0  0  0  0  0
       1  2  1  0  0  0  0
       1  3  1  0  0  0  0
       1  4  1  0  0  0  0
       1  5  1  0  0  0  0
     M  END
     $$$$

     #+end_example

   + a control of the above:

     #+begin_src bash :tangle no :output both :results output replace
echo "Check the .sdf generated:"
cat test_file_ob.sdf
     #+end_src

     #+RESULTS:
     #+begin_example
     Check the .sdf generated:

      OpenBabel01302220013D

       5  4  0  0  0  0  0  0  0  0999 V2000
         0.9519    0.0593   -0.0623 C   0  0  0  0  0  0  0  0  0  0  0  0
         2.7188    0.0593   -0.0623 Cl  0  0  0  0  0  0  0  0  0  0  0  0
         0.5948    1.0541   -0.3379 H   0  0  0  0  0  0  0  0  0  0  0  0
         0.5948   -0.1994    0.9369 H   0  0  0  0  0  0  0  0  0  0  0  0
         0.5948   -0.6767   -0.7860 H   0  0  0  0  0  0  0  0  0  0  0  0
       1  2  1  0  0  0  0
       1  3  1  0  0  0  0
       1  4  1  0  0  0  0
       1  5  1  0  0  0  0
     M  END
     $$$$
     #+end_example

   + assign a smiles from a .sdf by OpenBabel

     #+begin_src python :tangle no :output both :results output replace
from openbabel import pybel

for mymol in pybel.readfile("sdf", "test_file_ob.sdf"):
    print(mymol.write("smi"))
     #+end_src

     #+RESULTS:
     : CCl	
     : 

   + generate a .sdf from SMILES, rdkit

     #+begin_src python :tangle no :output both :results output replace
import rdkit
from rdkit import Chem
from rdkit.Chem import AllChem

mol = Chem.MolFromSmiles("CF")
with_hydrogens = Chem.AddHs(mol)
AllChem.EmbedMolecule(with_hydrogens,randomSeed=0xf00d) 
print(Chem.MolToMolBlock(with_hydrogens))

with open("test_file_rd.sdf", mode="w") as newfile:
    newfile.write(Chem.MolToMolBlock(with_hydrogens))
     #+end_src

     #+RESULTS:
     #+begin_example

          RDKit          3D

       5  4  0  0  0  0  0  0  0  0999 V2000
        -0.0524   -0.0120    0.0160 C   0  0  0  0  0  0  0  0  0  0  0  0
         1.3238   -0.1464   -0.1423 F   0  0  0  0  0  0  0  0  0  0  0  0
        -0.3175    0.0493    1.0931 H   0  0  0  0  0  0  0  0  0  0  0  0
        -0.3465    0.9303   -0.4647 H   0  0  0  0  0  0  0  0  0  0  0  0
        -0.6073   -0.8212   -0.5021 H   0  0  0  0  0  0  0  0  0  0  0  0
       1  2  1  0
       1  3  1  0
       1  4  1  0
       1  5  1  0
     M  END

     #+end_example

   + check of the above

     #+begin_src bash :tangle no :output both :results output replace
cat test_file_rd.sdf
     #+end_src

     #+RESULTS:
     #+begin_example

          RDKit          3D

       5  4  0  0  0  0  0  0  0  0999 V2000
        -0.0524   -0.0120    0.0160 C   0  0  0  0  0  0  0  0  0  0  0  0
         1.3238   -0.1464   -0.1423 F   0  0  0  0  0  0  0  0  0  0  0  0
        -0.3175    0.0493    1.0931 H   0  0  0  0  0  0  0  0  0  0  0  0
        -0.3465    0.9303   -0.4647 H   0  0  0  0  0  0  0  0  0  0  0  0
        -0.6073   -0.8212   -0.5021 H   0  0  0  0  0  0  0  0  0  0  0  0
       1  2  1  0
       1  3  1  0
       1  4  1  0
       1  5  1  0
     M  END
     #+end_example

   + assign SMILES from .sdf by RDKit

     #+begin_src python :tangle no :output both :results output replace
import rdkit
from rdkit import Chem
   
m = Chem.MolFromMolFile('test_file_rd.sdf')
print(Chem.MolToSmiles(m,isomericSmiles=False))

     #+end_src

     #+RESULTS:
     : CF

** construction of a Python script (~inchi-1~ with OpenBabel)

   For this first generation approach, only OpenBabel is used where RDKit would
   be an interesting, likely worth to check, complementary tool.

   + header

     #+begin_src python :tangle smiles_obsdf.py
#!/usr/bin/env python3

# name:    smiles_obsdf.py
# author:  nbehrnd@yahoo.com
# license: MIT 2022
# date:    2022-01-29 (YYYY-MM-DD)
# edit:    2022-02-09 (YYYY-MM-DD)

"""Monitor a round trip SMILES -> .sdf -> INCHI -> .sdf -> SMILES (obabel).

The aim is to monitor how reliable the reconstruction of .sdf from an InChI
string actually is.  It is assumed that a successful round trip (SMILES at start
matching SMILES at the end) requires InChI with fixed H-layer to account for
tautomerism.  However, it is not evident if this suffices for any organic
structure submitted as this; axial chirality (the motif of 1,1'-biphenyl,
TADDOL, BINAP, etc.) possibly present a difficulty here.

Anticipated input: a list of SMILES (e.g. by a DataWarrior library)
Anticipated output: a report about SMILES passing/failing this test.

This script relays some work to the nonstandard libraries of OpenBabel and
RDKit.  The assignment of InChI as well as the regeneration of .sdf requires the
reference InChI executable distributed by InChI trust (v. 1.06); here, the
version for Linux is anticipated."""

import argparse
import os
import subprocess

import openbabel
from openbabel import pybel


def get_args():
    """Get command-line arguments"""

    parser = argparse.ArgumentParser(
        usage="""Check round-trip SMILES -> .sdf -> INCHI -> .sdf -> SMILES.

The anticipated input file is a listing of SMILES to process (the file
extension does not matter).  Keep the inchi-1 executable (v 1.06) for
Linux by InChI trust (add the executable bit) in the same folder as
this script and provide with OpenBabel's Python libraries.

If an entry's canonical SMILES prior and after the round trip match
each other, the structure enters file success_structures.log.  Else,
the SMILES prior and after the round trip are recorded in the file
failing_structures.log.  The criterion currently deployed is OpenBabel's
canonical SMILES about the intermediate .sdf written.""")


    parser.add_argument("source_file",
                        metavar="FILE",
                        help="Input file containing a list of SMILES strings.")

    return parser.parse_args()
    #+end_src

   + split the input file into individual entries

     #+begin_src python :tangle smiles_obsdf.py
def split(input_file=""):
    """Read the SMILES into a list"""
    input_list = []
    with open(input_file, mode="r") as newfile:
        for entry in newfile:
            input_list.append(str(entry).strip())

    return input_list
     #+end_src

   + convert SMILES into OpenBabel SMILES/RDKit SMILES

     #+begin_src python :tangle smiles_obsdf.py
def smiles2obabel(initial_smiles=""):
    """Convert SMILES into OpenBabel's canonical SMILES."""
    mol = pybel.readstring("smi", initial_smiles)
    obabel_smiles = str(mol.write("can"))

    return obabel_smiles


def smiles2rdkit(initial_smiles=""):
    """Convert SMILES into RDKit's SMILES."""
    mol = Chem.MolFromSmiles(initial_smiles)
    rdkit_smiles = Chem.MolToSmiles(mol,isomericsmiles=False)

    return rdkit_smiles
     #+end_src

   + generate the initial .sdf file

     #+begin_src python :tangle smiles_obsdf.py
def sdf_obabel(raw_smiles=""):
    """Generate a .sdf with OpenBabel."""
    mol = pybel.readstring("smi", raw_smiles)
    mol.make3D()
    molecule = mol.write("sdf")

    with open("test_file.sdf", mode="w") as newfile:
        newfile.write(molecule)

def sdf_rdkit(raw_smiles=""):
    """Generate a .sdf with RDKit."""
    mol = Chem.MolFromSmiles(raw_smiles)
    with_hydrogens = Chem.AddHs(mol)
    molecule = Chem.MolToMolBlock(with_hydrogens)

    with open("test_file.sdf", mode="w") as newfile:
        newfile.write(molecule)
     #+end_src

   + perform the round trip
     #+begin_src python :tangle smiles_obsdf.py
def assign_inchi(initial_sdf=""):
    """Assign InChI on the initial .sdf.

    Input:   test_file.sdf
    Output:  inchi.txt"""
    process=subprocess.Popen(["./inchi-1",  "-fixedH",
                              "test_file.sdf", "inchi.txt"],
                              shell=False)
    process.communicate()

    for file in os.listdir("."):
        if (file.endswith(".sdf") or
            file.endswith(".log") or file.endswith(".prb")):
            os.remove(file)


def assign_inchi_auxiliary():
    """Generate an auxiliary for a structure recovery.

    Input:  inchi.txt
    Output: auxiliary.txt"""
    process=subprocess.Popen(["./inchi-1", "-InChI2Struct",
                              "inchi.txt", "auxiliary.txt"],
                              shell=False)
    process.communicate()

    for file in os.listdir("."):
        if (file.endswith(".log") or file.endswith(".prb")):
            os.remove(file)
    os.remove("inchi.txt")


def generate_inchi_sdf():
    """Let InChI generate a .sdf.

    Input:  auxiliary.txt
    Output: output.sdf"""
    process=subprocess.Popen(["./inchi-1", "-OutputSDF",
                              "auxiliary.txt", "output.sdf"],
                             shell=False)
    process.communicate()

    for file in os.listdir("."):
        if (file.endswith(".log") or file.endswith(".prb")):
            os.remove(file)
    os.remove("auxiliary.txt")
     #+end_src

   + return the SMILES about the new .sdf file

     #+begin_src python :tangle smiles_obsdf.py
def trim_sdf_file():
    """Remove the superfluous leading lines inchi-1 wrote in the .sdf."""
    register = []

    with open("output.sdf", mode="r") as newfile:
        register = newfile.readlines()
        register = register[1:]

    with open("output.sdf", mode="w") as newfile:
        for line in register:
            newfile.write(f"{line}")


def obabel_newsmiles():
    """Assign the canonical SMILES by OpenBabel on the new structure."""
    new_smiles = ""
    for mol in pybel.readfile("sdf", "output.sdf"):
        new_smiles = mol.write("can")

    return new_smiles


def rdkit_smiles():
    """Assign the SMILES by RDKit on the new structure."""
    new_smiles = ""
    mol = Chem.MolFromMolFile("output.sdf")
    new_smiles = Chem.MolToSmiles(mol, isomericsmiles=False)

    return new_smiles
     #+end_src

   + footer

     #+begin_src python :tangle smiles_obsdf.py
def main():
    """Join the functions."""
    args = get_args()
    input_file = args.source_file

    success = []
    failing = []
    counter = int(1)

    listed = split(input_file)
    for entry in listed:
        raw_smiles = ""
        raw_smiles = str(smiles2obabel(entry))
        raw_smiles = raw_smiles.split()[0]

        sdf_obabel(raw_smiles)

        assign_inchi("test_file.sdf")
        assign_inchi_auxiliary()
        generate_inchi_sdf()

        trim_sdf_file()

        new_smiles = str(obabel_newsmiles()).strip().split()[0]

        if str(raw_smiles) == str(new_smiles).split()[0]:
            retain = "\t".join([str(counter), raw_smiles, new_smiles])
            success.append(retain)
        else:
            retain = "\t".join([str(counter), raw_smiles, new_smiles])
            failing.append(retain)
        counter += int(1)
    os.remove("output.sdf")

    print("\n---- ----\n")
    print("Brief report:")
    print(f"success structures: {len(success)}")
    with open("success_structures.log", mode="w") as newfile:
        newfile.write("counter\tSMILES (prior)\tSMILES (after) round trip:\n")
        for entry in success:
            newfile.write(f"{entry}\n")
        newfile.write("END")

    print(f"failing structures: {len(failing)}")
    with open("failing_structures.log", mode="w") as newfile:
        newfile.write("counter\tSMILES (prior)\tSMILES (after) round trip:\n")
        for entry in failing:
            newfile.write(f"{entry}\n")
        newfile.write("\nEND")

    print("\nCheck file 'success_structures.log' and 'failing_structures.log'.")


if __name__ == "__main__":
    main()
     #+end_src
     
** check script for smiles_obsdf.py

   Modifications in the code may introduce unwanted changes in the results
   tangled ~smiles_obsdf.py~ provides.  To be informed early about them, a
   dedicated test based on pytest.

   #+begin_src python :tangle test_smiles_obsdf.py
#!/bin/usr/env python3

# name:    test_smiles_obsdf.py
# author:  nbehrnd@yahoo.com
# license: GPL v3, 2022
# date:    2022-02-07 (YYYY-MM-DD)
# edit:
#

"""Provide basic testing about script smiles_obsdf.py's round trip.

For the initial run with the set 100_smiles.txt, 57/100 entries did not pass
successfully the round trip Openbabel SMILES -> OpenBabel .sdf -> InChI string
-> InChI .sdf -> OpenBabel SMILES.  To identify systematic errors in own
programming early, this script tests the processing with pytest when calling

pytest -v test_smiles_obsdf.py

Proper execution of this test script depends on the presence of smiles_obsdf.py
in the same directory as this script, test_smiles_obsdf.py.  It equally requires
the InChI trust reference executable for Linux, an working installation of the
non-standard Python libraries about OpenBabel and Pytest (for Python3).
Depending on the Linux distribution used, Pytest (for Python3) might be called
by either pytest, or explicit pytest-3."""
import os
from subprocess import getstatusoutput, getoutput

import pytest

PROGRAM = str("./smiles_obsdf.py")
TFILE = str("testfile.smi")


def write_testfile(SMILES=""):
    """Provide a file with the input structure."""
    with open(TFILE, mode="w") as newfile:
        newfile.write(str(SMILES))


def make_tester(structure=""):
    """Provide the frame to perform tests on varying SMILES strings."""
    smiles = ""
    smiles = str(structure)
    write_testfile(SMILES=smiles)
    assert os.path.isfile(TFILE)

    test = getoutput(f"python3 {PROGRAM} {TFILE}")
    assert os.path.isfile("failing_structures.log")
    assert os.path.isfile("success_structures.log")

    register = []
    success_reader = ""
    with open("success_structures.log", mode="r") as source:
        register = source.readlines()
    success_reader = str(register[1]).split()[0]
    assert success_reader == str("1")

    try:
        for file in ["testfile.smi",
                     "failing_structures.log", "sucess_structures.log"]:
            os.remove(file)
    except OSError:
        print(f"Remove of file '{file}' failed.")


def test_dimethylether():
    """Check a structure not prone to tautomerism."""
    make_tester(structure="COC")


def test_2hydroxypyridine():
    """Check a structure prone to tautomerism, 1/2."""
    make_tester(structure="Oc1ccccn1")


def test_2pyridone():
    """Check a structure prone to tautomerism, 2/2."""
    make_tester(structure="O=c1cccc[nH]1")
   #+end_src


   
** Wrapper script for the InChI trust binary

   DataWarrior may export the library of drug-like molecules as a .sdf file
   which in turn may be processed by InChI trust's current reference executable
   (version 1.06) to assign InChI, as well as to perform the reconstruction of
   /a/ .sdf file.

   Thus, a naive approach may probe the success of a round trip by comparison of
   the InChI strings (non-standard for their inclusion of the fixed H-layer)
   prior and after processing the structures.  This possibly mutates the call
   for OpenBabel (or RDKit) for the assignment of SMILES into an option, rather
   then a strict necessity.

   + header

     #+begin_src python :tangle inchi_sdf.py
#!/usr/bin/env python3

# name:    inchi_sdf.py
# author:  nbehrnd@yahoo.com
# license: MIT 2022
# date:    2022-02-01 (YYYY-MM-DD)
# edit:    2022-02-09 (YYYY-MM-DD)

"""Monitor a round trip .sdf -> InChI -> .sdf, InChI executable.

Starting from a multi-model .sdf non-zero coordinates, this script relies on
modules of the Python standard library and InChI trusts' reference executable
(version 1.06).  This script, InChI trust's executable (with the added
executable bit), and the data to process are expected to reside in the same
folder.

Anticipated input:  multi-model .sdf (e.g., by DataWarrior)
Anticipated output: a report about structures passing/failing this test.

The criterion for passing the round trip is an invariant InChI string."""

import argparse
import os
import subprocess


def get_args():
    """Get command-line arguments"""

    parser = argparse.ArgumentParser(
        usage="""Check round-trip .sdf -> INCHI -> .sdf with InChI v1.06.

The anticipated input file is a multi-model .sdf file to process (the file
extension does not matter).  Keep the inchi-1 executable (v 1.05) for Linux by
InChI trust (add the executable bit) in the same folder as this script and
provide with OpenBabel's Python libraries.

If an entry's non-standard InChI (fixed H-layer) prior and after the round trip
match each other, the structure enters file success_structures.log.  Else, the
entry is reported in file failing_structures.log.""")


    parser.add_argument("source_file",
                        metavar="FILE",
                        help="Input .sdf file containing a list molecules.")

    return parser.parse_args()


def model_lister(input_file=""):
    """Return the model data of a .sdf as a listing.

This counts (x + 1) entries and looses the terminal `$$$$` string of each model."""
    all_model_data = ""
    register = []

    with open(input_file, mode="r") as source:
        for line in source:
            all_model_data += "".join([str(line)])
            
  #  del register[0]
    register = all_model_data.split("$$$$\n")
    return register
     #+end_src

   + initial screening by InChI trust's executable
     
     #+begin_src python :tangle inchi_sdf.py
def assign_primary_inchi(input_model=""):
    """Assign the primary InChI to the original datum.

    Input:  the primary .sdf string
    Output: the primary InChI string."""
    register = []
    primary_inchi = ""

    with open("testfile.sdf", mode="w") as newfile:
        newfile.write(input_model)
        newfile.write("$$$$\n")
        
    process=subprocess.Popen(["./inchi-1", "-FixedH", "-AuxNone",
                              "-NoLabels",
                              "testfile.sdf", "primary_inchi.txt"],
                             shell=False)
    process.communicate()

    try:
        with open("primary_inchi.txt", mode="r") as source:
            register = source.readlines()
            primary_inchi = str(register[0]).strip()
    except OSError:
        print("No access to 'primary_inchi.txt'.")

    for file in ["testfile.sdf",
                 "testfile.sdf.prb", "testfile.sdf.log",
                 "primary_inchi.txt"]:
        try:
            os.remove(file)
        except OSError:
            print(f"Remove of file '{file}' was unsuccessful.")

    return primary_inchi
     #+end_src

   + structure generation from InChIs

     #+begin_src python :tangle inchi_sdf.py
def assign_inchi_auxiliary(inchi_string=""):
    """Generate an auxiliary file for a structure recovery.

    Input:  the primary InChI string (cf. function assign_primary_inchi)
    Output: a temporary auxiliary.txt"""
    with open("testfile.txt", mode="w") as newfile:
        newfile.write(inchi_string)

    process=subprocess.Popen(["./inchi-1", "-InChI2Struct",
                              "testfile.txt", "auxiliary.txt"],
                              shell=False)
    process.communicate()

    for file in ["testfile.txt",
                 "testfile.txt.log", "testfile.txt.prb"]:
        try:
            os.remove(file)
        except OSError:
            print(f"Remove of file '{file}' was unsuccessful.")


def generate_inchi_sdf():
    """Based on an auxiliary, let InChI generate a .sdf.

    Input:  auxiliary.txt
    Output: output.sdf"""

    process=subprocess.Popen(["./inchi-1", "-OutputSDF",
                              "auxiliary.txt", "output.sdf"],
                             shell=False)
    process.communicate()

    for file in ["auxiliary.txt",
                 "auxiliary.txt.log", "auxiliary.txt.prb"]:
        try:
            os.remove(file)
        except OSError:
            print(f"Remove of file '{file}' was unsuccessful.")


def correct_secondary_sdf():
    """As already filed, there is a superfluous heading line in InChI's .sdf"""
    register = []
    try:
        with open("output.sdf", mode="r") as source:
            for line in source:
                register.append(str(line).rstrip())
        del register[0]

        with open("output.sdf", mode="w") as newfile:
            for entry in register:
                newfile.write(f"{entry}\n")
    except OSError:
        print(f"correction of InChI's .sdf failed.")
     #+end_src

   + second assignment of InChI, now on .sdf with zero-coordinates

     #+begin_src python :tangle inchi_sdf.py
def assign_secondary_inchi():
    """Assign InChI on the newly generated .sdf.

    Input:   output.sdf
    Output:  secondary InChI string"""
    register = []
    secondary_inchi = ""
    
    process=subprocess.Popen(["./inchi-1", "-fixedH", "-AuxNone",
                              "-NoLabels",
                              "output.sdf", "secondary_inchi.txt"],
                              shell=False)
    process.communicate()

    try:
        with open("secondary_inchi.txt", mode="r") as source:
            register = source.readlines()
            secondary_inchi = str(register[0]).strip()
    except OSError:
        print(f"Assignment secondary InChI failed.")

    try:
        for file in ["output.sdf",
                    "output.sdf.log", "output.sdf.prb",
                    "secondary_inchi.txt"]:
            os.remove(file)
    except OSError:
        print(f"Removal of file '{file}' failed.")

    return secondary_inchi
     #+end_src

   + footer

     #+begin_src python :tangle inchi_sdf.py
def main():
    """Join the functions.

Reading a .sdf file which may contain one datum, or multiple model data,
the round trip's InChI strings per model are compared with each other.  If
they match pairwise, the round trip was successful; else, it failed.  The
script is going to write two new .sdf files according to these categories."""
    success = []
    failing = []
    counter = int(1)

    args = get_args()
    input_file = args.source_file
    list_of_models = model_lister(input_file=input_file)

    for entry in list_of_models[:-1]:
        primary_inchi = ""
        secondary_inchi = ""

        primary_inchi = assign_primary_inchi(input_model=entry)

        assign_inchi_auxiliary(inchi_string=primary_inchi)
        generate_inchi_sdf()
        correct_secondary_sdf()

        secondary_inchi = assign_secondary_inchi()

        if primary_inchi == secondary_inchi:
            success.append(f"{counter}\t{primary_inchi}\t{secondary_inchi}")
        else:
            failing.append(f"{counter}\t{primary_inchi}\t{secondary_inchi}")
        counter += int(1)

    print("\n---- ----\n")
    print("Brief report:")
    print(f"success structures: {len(success)}")
    with open("success_structures.log", mode="w") as newfile:
        newfile.write("successful round trips\n")
        newfile.write("\t".join(['counter',
                                 'primary InChI', 'secondary InChI\n']))
        for entry in success:
            newfile.write(f"{entry}\n")
        newfile.write("END")

    print(f"failing structures: {len(failing)}")
    with open("failing_structures.log", mode="w") as newfile:
        newfile.write("failing round trips:\n")
        newfile.write("\t".join(['counter',
                                 'primary InChI', 'secondary InChI\n']))
        for entry in failing:
            newfile.write(f"\n{entry}")
        newfile.write("\nEND")

    print("\nCheck file 'success_structures.log' and 'failing_structures.log'.")


if __name__ == "__main__":
    main()
     #+end_src

** Checker for ~inchi_sdf.py~, script ~test_inchi_sdf.py~

   Ahead of script ~inchi_sdf.py~ to run over libraries of test molecules, test
   script ~test_inchi_sdf.py~ shall identify systematic errors in the
   implementation of the former by submission of individual molecules.

   #+begin_src python :tangle test_inchi_sdf.py
#!/usr/bin/env python3

# name:    test_inchi_sdf.py
# author:  nbehrnd@yahoo.com
# license: MIT, 2022
# date:    2022-07-02 (YYYY-MM-DD)
# edit:    2022-09-02 (YYYY-MM-DD)
#

"""Identify systematic errors in inchi_sdf.py in a round trip.

Script inchi_sdf.py aims to monitor the round trip of .sdf for which InChI
trust's reference executable is going to assign a primary InChI string.  Based
on this reduced representation, InChI trust's reference executable then
reconstructs a .sdf for which again a -- then secondary -- InChI string is
assigned.  Thus, except for the generation of the initial .sdf file, this is
round trip independent of interaction by OpenBabel, or RDKit.  This script
test_inchi_sdf.py shall detect problems in the implementation of the intended
round trip, well ahead of working on libraries of molecules.

Deployment with pytest for Python 3 which may -- depending on the Linux
distribution used -- may be accessible by pytest, or pytest-3

pytest -v test_inchi_sdf.py

The execution depends on the simultaneous presence of this script, InChI trust's
reference binary for Linux (version 1.06), and inchi_sdf.py."""
import os
from subprocess import getstatusoutput, getoutput

import pytest

PROGRAM = str("./inchi_sdf.py")
TFILE = str("testfile.sdf")

def write_testfile(model=""):
    """Provide a file with a single input structure."""
    with open(TFILE, mode="w") as newfile:
        newfile.write(str(model))


def make_tester(model=""):
    """Provide the frame to perform a mono-model test."""
    register = []
    check = ""
    write_testfile(model=model)

    test = getoutput(f"python3 {PROGRAM} {TFILE}") # export

    try:
        with open("success_structures.log", mode="r") as source:
            register = source.readlines()
        check = str(register[2])
    except OSError:
        print("File 'success_structures.log' inaccessible.  Exit.")

    assert str(check[0]) == str("1")


def test_dimethylether():
    """Check a structure not prone to tautomerism."""
    model=str("""
 OpenBabel020722

  9  8  0  0  0  0  0  0  0  0999 V2000
    1.0496    0.0176   -0.0708 C   0  0  0  0  0  0  0  0  0  0  0  0
    2.4706    0.0409   -0.0805 O   0  0  0  0  0  0  0  0  0  0  0  0
    2.9681    1.2713   -0.5890 C   0  0  0  0  0  0  0  0  0  0  0  0
    0.7233   -0.9468    0.3277 H   0  0  0  0  0  0  0  0  0  0  0  0
    0.6579    0.1267   -1.0868 H   0  0  0  0  0  0  0  0  0  0  0  0
    0.6579    0.8122    0.5717 H   0  0  0  0  0  0  0  0  0  0  0  0
    4.0606    1.2342   -0.5737 H   0  0  0  0  0  0  0  0  0  0  0  0
    2.6377    2.1060    0.0369 H   0  0  0  0  0  0  0  0  0  0  0  0
    2.6377    1.4205   -1.6216 H   0  0  0  0  0  0  0  0  0  0  0  0
  1  2  1  0  0  0  0
  1  4  1  0  0  0  0
  1  5  1  0  0  0  0
  1  6  1  0  0  0  0
  2  3  1  0  0  0  0
  3  7  1  0  0  0  0
  3  8  1  0  0  0  0
  3  9  1  0  0  0  0
M  END
$$$$
""")
    make_tester(model=model)


def test_2hydroxypyridine():
    """Check on a structure subject to tautomerism, 1/2."""
    model=str("""
 OpenBabel020922

 12 12  0  0  0  0  0  0  0  0999 V2000
    1.1010    0.0362    0.2292 O   0  0  0  0  0  0  0  0  0  0  0  0
    2.4532    0.1277    0.0818 C   0  0  0  0  0  0  0  0  0  0  0  0
    3.0800    1.3588   -0.0232 C   0  0  0  0  0  0  0  0  0  0  0  0
    4.4624    1.3765   -0.1859 C   0  0  0  0  0  0  0  0  0  0  0  0
    5.1572    0.1724   -0.2356 C   0  0  0  0  0  0  0  0  0  0  0  0
    4.4357   -1.0046   -0.1155 C   0  0  0  0  0  0  0  0  0  0  0  0
    3.0966   -1.0509    0.0435 N   0  0  0  0  0  0  0  0  0  0  0  0
    0.7330    0.9279    0.1589 H   0  0  0  0  0  0  0  0  0  0  0  0
    2.5246    2.2874    0.0199 H   0  0  0  0  0  0  0  0  0  0  0  0
    4.9939    2.3198   -0.2738 H   0  0  0  0  0  0  0  0  0  0  0  0
    6.2335    0.1504   -0.3648 H   0  0  0  0  0  0  0  0  0  0  0  0
    4.9303   -1.9708   -0.1450 H   0  0  0  0  0  0  0  0  0  0  0  0
  1  2  1  0  0  0  0
  1  8  1  0  0  0  0
  2  3  1  0  0  0  0
  2  7  2  0  0  0  0
  3  4  2  0  0  0  0
  3  9  1  0  0  0  0
  4  5  1  0  0  0  0
  4 10  1  0  0  0  0
  5  6  2  0  0  0  0
  5 11  1  0  0  0  0
  6  7  1  0  0  0  0
  6 12  1  0  0  0  0
M  END
$$$$
""")


def test_2pyridone():
    """Check on a structure subject to tautomerism, 2/2."""
    model=str("""
 OpenBabel020922

 12 12  0  0  0  0  0  0  0  0999 V2000
    2.1606    0.0524    0.0004 O   0  0  0  0  0  0  0  0  0  0  0  0
    0.9356    0.0285    0.0010 C   0  0  0  0  0  0  0  0  0  0  0  0
    0.1384    1.2834    0.0009 C   0  0  0  0  0  0  0  0  0  0  0  0
   -1.2014    1.2181   -0.0004 C   0  0  0  0  0  0  0  0  0  0  0  0
   -1.8769   -0.0594   -0.0011 C   0  0  0  0  0  0  0  0  0  0  0  0
   -1.1608   -1.1905    0.0010 C   0  0  0  0  0  0  0  0  0  0  0  0
    0.2101   -1.1399    0.0021 N   0  0  0  0  0  0  0  0  0  0  0  0
    0.6873    2.2152    0.0021 H   0  0  0  0  0  0  0  0  0  0  0  0
   -1.8036    2.1203   -0.0002 H   0  0  0  0  0  0  0  0  0  0  0  0
   -2.9616   -0.0773   -0.0031 H   0  0  0  0  0  0  0  0  0  0  0  0
   -1.6167   -2.1750    0.0015 H   0  0  0  0  0  0  0  0  0  0  0  0
    0.7533   -1.9942    0.0027 H   0  0  0  0  0  0  0  0  0  0  0  0
  1  2  2  0  0  0  0
  2  3  1  0  0  0  0
  2  7  1  0  0  0  0
  3  4  2  0  0  0  0
  3  8  1  0  0  0  0
  4  5  1  0  0  0  0
  4  9  1  0  0  0  0
  5  6  2  0  0  0  0
  5 10  1  0  0  0  0
  6  7  1  0  0  0  0
  6 11  1  0  0  0  0
  7 12  1  0  0  0  0
M  END
$$$$
""")
#+end_src


** construction of a Python script for SMILES, RDKit and ~inchi-1~

   The underlying speculation is that the assignment of SMILES by OpenBabel and
   RDKit differs how SMILES /convey/ the underlying structure (like
   inchified/canonical SMILES in OpenBabel's parlance).  Perhaps this difference
   yields a different rate of success, i.e. a different frequency of primary and
   secondary SMILES about an enntry matching each other.

   + header

     #+begin_src python :tangle smiles_rdkit.py
#!/usr/bin/env python3

# name:    smiles_rdkit.py
# author:  nbehrnd@yahoo.com
# license: MIT 2022
# date:    2022-01-09 (YYYY-MM-DD)
# edit:

"""Monitor a round trip SMILES > .sdf > InChI > .sdf > SMILES (rdkit).

Starting with a list of SMILES, RDKit will assign a unique primary SMILES
and generate a .sdf for an InChI assignment by InChI trust's reference
executable.  InChI trust's reference executable recreates a new .sdf for
RDKit's assignment of a secondary SMILES.

The round trip is successful if the two SMILES strings match each other.

For a successful execution, deposit this script with inchi-1 and the
.sdf to process in the same folder.  Provide inchi-1 the executable bit.
RDKit is not part of Python's standard library."""

import argparse
import os
import subprocess

import rdkit
from rdkit import Chem
from rdkit.Chem import AllChem

def get_args():
    """Get command-line arguments"""

    parser = argparse.ArgumentParser(
        usage="""Check round-trip SMILES -> .sdf -> INCHI -> .sdf -> SMILES.

The anticipated input file is a listing of SMILES to process (the file
extension does not matter).  Keep the inchi-1 executable (v 1.06) for
Linux by InChI trust (add the executable bit) in the same folder as
this script and provide with RDKit's Python libraries.

If an entry's isomeric SMILES prior and after the round trip match
each other, the structure enters file success_structures.log.  Else,
the SMILES prior and after the round trip are recorded in the file
failing_structures.log.  The criterion currently deployed is OpenBabel's
canonical SMILES about the intermediate .sdf written.""")


    parser.add_argument("source_file",
                        metavar="FILE",
                        help="Input file containing a list of SMILES strings.")

    return parser.parse_args()
     #+end_src

   + split the input file into individual entries

     #+begin_src python :tangle smiles_rdkit.py
def split(input_file=""):
    """Read the SMILES into a list"""
    input_list = []
    with open(input_file, mode="r") as newfile:
        for entry in newfile:
            input_list.append(str(entry).strip())

    return input_list
     #+end_src

   + convert SMILES into OpenBabel SMILES/RDKit SMILES

     #+begin_src python :tangle smiles_rdkit.py
def smiles2rdkit(initial_smiles=""):
    """Convert SMILES into RDKit's SMILES."""
    mol = Chem.MolFromSmiles(initial_smiles)
    rdkit_smiles = Chem.MolToSmiles(mol)

    return rdkit_smiles
     #+end_src

   + generate the initial .sdf files

     #+begin_src python :tangle smiles_rdkit.py
def sdf_rdkit(raw_smiles=""):
    """Generate a .sdf with RDKit."""
    mol = Chem.MolFromSmiles(raw_smiles)
    with_hydrogens = Chem.AddHs(mol)
    molecule = Chem.MolToMolBlock(with_hydrogens)

    with open("test_file.sdf", mode="w") as newfile:
        newfile.write(molecule)
     #+end_src
     
   + perform the round trip
     #+begin_src python :tangle smiles_rdkit.py
def assign_inchi():
    """Assign InChI on the initial .sdf.

    Input:   test_file.sdf
    Output:  inchi.txt"""
    register = []
    inchi = ""
    
    process=subprocess.Popen(["./inchi-1",  "-fixedH",
                              "test_file.sdf", "inchi.txt"],
                              shell=False)
    process.communicate()

    with open("inchi.txt", mode="r") as source:
        register = source.readlines()
        inchi = str(register[0])
        
    try:
        for file in ["test_file.sdf",
                     "test_file.sdf.log", "test_file.sdf.prb"]:
            os.remove(file)
    except OSError:
        print(f"Remove of '{file}' failed.")

    return inchi


def assign_inchi_auxiliary():
    """Generate an auxiliary for a structure recovery.

    Input:  inchi.txt
    Output: auxiliary.txt"""
    process=subprocess.Popen(["./inchi-1", "-InChI2Struct",
                              "inchi.txt", "auxiliary.txt"],
                              shell=False)
    process.communicate()

    for file in os.listdir("."):
        if (file.endswith(".log") or file.endswith(".prb")):
            os.remove(file)
    os.remove("inchi.txt")


def generate_inchi_sdf():
    """Let InChI generate a .sdf.

    Input:  auxiliary.txt
    Output: output.sdf"""
    process=subprocess.Popen(["./inchi-1", "-OutputSDF",
                              "auxiliary.txt", "output.sdf"],
                             shell=False)
    process.communicate()

    for file in os.listdir("."):
        if (file.endswith(".log") or file.endswith(".prb")):
            os.remove(file)
    os.remove("auxiliary.txt")
     #+end_src

   + return the SMILES about the new .sdf file

     #+begin_src python :tangle smiles_rdkit.py
def trim_sdf_file():
    """Remove the superfluous leading lines inchi-1 wrote in the .sdf."""
    register = []

    with open("output.sdf", mode="r") as newfile:
        register = newfile.readlines()
        register = register[1:]

    with open("output.sdf", mode="w") as newfile:
        for line in register:
            newfile.write(f"{line}")

def rdkit_smiles():
    """Assign the SMILES by RDKit on the new structure."""
    new_smiles = ""
    mol = Chem.MolFromMolFile("output.sdf")
    new_smiles = Chem.MolToSmiles(mol)

    return new_smiles
     #+end_src

   + footer

     #+begin_src python :tangle smiles_rdkit.py
def main():
    """Join the functions."""
    args = get_args()
    input_file = args.source_file

    success = []
    failing = []
    counter = int(1)
    
    listed = split(input_file)
    for entry in listed:
        raw_smiles = ""
        raw_smiles = str(smiles2rdkit(initial_smiles=entry))  #.strip()))
        raw_smiles = raw_smiles.split()[0]

        sdf_rdkit(raw_smiles=raw_smiles)
        primary_inchi = assign_inchi()
        assign_inchi_auxiliary()
        generate_inchi_sdf()
        trim_sdf_file()
        secundary_smiles = rdkit_smiles()

        if raw_smiles == secundary_smiles:
            success.append(f"{counter}\t{raw_smiles}\t{secundary_smiles}")
        else:
            failing.append(f"{counter}\t{raw_smiles}\t{secundary_smiles}")
        counter += int(1)
        os.remove("output.sdf")

    print("\n---- ----\n")
    print("Brief report:")
    print(f"success structures: {len(success)}")
    with open("success_structures.log", mode="w") as newfile:
        newfile.write("SMILES (prior)\tSMILES (after) round trip:\n")
        for entry in success:
            newfile.write(f"{entry}\n")
        newfile.write("END")

    print(f"failing structures: {len(failing)}")
    with open("failing_structures.log", mode="w") as newfile:
        newfile.write("SMILES (prior)\tSMILES (after) round trip:\n")
        for entry in failing:
            newfile.write(f"{entry}\n")
        newfile.write("\nEND")

    print("\nCheck file 'success_structures.log' and 'failing_structures.log'.")


if __name__ == "__main__":
    main()
     #+end_src

** check script for ~smiles_rdkit.py~, i.e. ~test_smiles_rdkit.py~

   Again, provide a basic check for the implementation.

   #+begin_src python :tangle test_smiles_rdkit.py
#!/bin/usr/env python3

# name:    test_smiles_rdkit.py
# author:  nbehrnd@yahoo.com
# license:
# date:    2022-02-10 (YYYY-MM-DD)
# edit:
#

"""Elementar testing about script smiles_rdkit.py."""
import os                                         
from subprocess import getstatusoutput, getoutput    #+end_src
                                                  
import pytest

PROGRAM = str("./smiles_rdkit.py")
TFILE = str("testfile.smi")


def write_testfile(SMILES=""):
    """Provide a file with the input structure."""
    with open(TFILE, mode="w") as newfile:
        newfile.write(str(SMILES))


def make_tester(structure=""):
    """Provide the frame to perform tests on varying SMILES strings."""
    smiles = ""
    smiles = str(structure)
    write_testfile(SMILES=smiles)
    assert os.path.isfile(TFILE)

    test = getoutput(f"python3 {PROGRAM} {TFILE}")
    assert os.path.isfile("failing_structures.log")
    assert os.path.isfile("success_structures.log")

    register = []
    success_reader = ""
    with open("success_structures.log", mode="r") as source:
        register = source.readlines()
        success_reader = register[1].split()[0]
    assert success_reader == str("1")

    try:
        for file in ["testfile.smi",
                     "failing_structures.log", "success_structures.log"]:
            os.remove(file)
    except OSError:
        print(f"Remove of file '{file}' failed.")


def test_dimethylether():
    """Check a structure not prone to tautomerism."""
    make_tester(structure="COC")


def test_2hydroxypyridine():
    """Check a structure prone to tautomerism, 1/2."""
    make_tester(structure="Oc1ccccn1")


def test_2pyridone():
    """Check a structure prone to tautomerism, 2/2."""
    make_tester(structure="O=c1cccc[nH]1")

   #+end_src
* Approach with Jmol

  [[https://jmol.sourceforge.net][Jmol]] recently was enabled to recognize isomeric structures as tautomers if
  these share a standard InChI, but differ in their non-standard InChI with
  fixed H-layer (cf. post on Jmol's [[https://sourceforge.net/p/jmol/mailman/message/37417385/][user list]] (<2022-01-14 Fri>, root), or the
  subsequent announcement to InChI's [[https://sourceforge.net/p/inchi/mailman/message/37593452/][discussion board]] (<2022-01-19 Wed>)).

  For two individual .sdf about 2-hydroxy pyridine (~M1.sdf~) and 2-pyridone
  (~M2.sdf~), the approach in Jmol's console is
  #+begin_src bash :tangle no
load file "M1.sdf" "M2.sdf";

print compare({1.1}, {2.1}, "isomer")
print compare({1.1}, {2.1}, "isomer", true)
  #+end_src
  where the first check identifies the two as constitutional, the second as
  tautomeric isomers.

  For a programmatic scrutiny of batches of molecular formulae, Jmol's action
  may be scripted and run e.g., with ~JmolData.jar~, or in a headerless instance
  with ~Jmol.jar -ions~.  Difficulties to perform the following were removed by
  <2022-02-15 Tue> with the release of Jmol (14.32.22).

  + A MWE to survey Jmol assigned SMILES and InChI:

    #+begin_src java :tangle structure_iterate.spt
// name:    structure_iterate.spt
// author:  nbehrnd@yahoo.com
// license:
// date:    2022-02-16 (YYYY-MM-DD)
// edit:    2022-02-17 (YYYY-MM-DD)

// Jmol may iterate over the entries of a multi-model .sdf file to
// report e.g., SMILES, standard InChI, InChI with fixed H-layer.
//
// Based on the sequential approach shown to optimize structures
//
// https://chemapps.stolaf.edu/jmol/docs/#minimize
//
// Use with Jmol 14.32.22 (released by 2022-02-15), or later, by either
//
// ./Jmol.jar -ions structure_iterate.spt
// ./JmolData.jar structure_iterate.spt
//
// with molecules.sdf present in the same folder.  For this, Jmol does
// not appear to depend on the NIH cactus server.

load MODELS {0, -1, 1} "molecules.sdf";  // work with all the models

var n = {*}.model.max;  // determine the length of the model list

for (var i = 1; i <= n; i++){
    frame @i;
    //    inchi_string = {thisModel}.find("inchi");
    inchi_string = {thisModel}.find("inchi", "fixedH");
    print "Structure: " + i + "\t" + inchi_string
};
    #+end_src

  + A MWE to reconstruct structures with Jmol from InChI

    #+begin_src java :tangle structure_reco.spt
// name:    structure_reco.spt
// author:  nbehrnd@yahoo.com
// license:
// date:    2022-02-16 (YYYY-MM-DD)
// edit:

// Based on an InChI string, Jmol may reconstruct the structre.
// Credit for the method to Robert Hansen, e-mail by 2022-01-18,
// https://sourceforge.net/p/jmol/mailman/message/37419647/ , and 
// corrections toward Jmol 14.32.22 (released by 2022-02-15)
// https://sourceforge.net/p/jmol/mailman/message/37610840/ .
//
// For the InChI2structure conversion, Jmol relays to the NIH cactus
// server.  To be used either by
//
// ./JmolData.jar structure_reco.spt 
// ./Jmol.jar -ions structure_reco.spt


// "InChI=1S/C17H19NO3/c1-18-7-6-17-10-3-5-13(20)16(17)21-15-12(19)4-2-9(14(15)17)8-11(10)18/h2-5,10-11,13,16,19-20H,6-8H2,1H3/t10-,11+,13-,16-,17-/m0/s1"; // Robert Hansen's test formula (morphine)

inchiString = "InChI=1S/C5H5NO/c7-5-3-1-2-4-6-5/h1-4H,(H,6,7)"  // both 2-hydroxy pyridine and 2-pyridone
// inchiString = "InChI=1/C5H5NO/c7-5-3-1-2-4-6-5/h1-4H,(H,6,7)/f/h7H"  // M1, 2-hydroxy pyridine, fixedH
// inchiString = "InChI=1/C5H5NO/c7-5-3-1-2-4-6-5/h1-4H,(H,6,7)/f/h6H"  // M2, 2-pyridone, fixedH
// inchiString = "InChI=1S/C8H8O3/c9-7(8(10)11)6-4-2-1-3-5-6/h1-5,7,9H,(H,10,11)/t7-/m0/s1"  // (S)-mandelic acid
// inchiString = "InChI=1S/C8H8O3/c9-7(8(10)11)6-4-2-1-3-5-6/h1-5,7,9H,(H,10,11)/t7-/m1/s1"  // (R)-mandelic acid


smilesString = inchiString.inchi("SMILES")
print smilesString


load @{"$"+smilesString}  // not needed for running Jmol.jar with -ions
    #+end_src
    It is noteworthy that the reconstruction successfully trades with the
    non-standard InChI about 2-hydroxy pyridine and 2-pyridone to yield either
    one tautormer.

  + Construction of a InChI round trip with Jmol, departing from .sdf

    #+begin_src java :tangle jmol_sdf.spt
// name:    jmol_sdf.spt
// author:  nbehrnd@yahoo.com
// license:
// date:    2022-02-17 (YYYY-MM-DD)
// edit:    2022-02-18 (YYYY-MM-DD)

// Departing form an entry in a multi-model .sdf, Jmol assigns a primary InChI
// with fixed H-layer.  This one is used by Jmol to build an intermediate .sdf
// for which Jmol writes a secondary InChI string with fixed H-layer.  The round
// trip qualifies as successful if the InChI string is invariant.
//
// Written for Jmol 14.32.22 (released by 2022-02-15) in Linux Debian
// 12/bookworm (branch testing).  The execution relies on accessing the NIH
// cactus server.  To be used by, e.g.
//
// ./Jmol.jar -ions jmol_sdf.spt
//
// in presence of molecules.sdf containing the data to probe.

load MODELS {0, -1, 1} "molecules.sdf";  // work with all the models

var n = {*}.model.max;  // length of the model list
success = 0;
failing = 0;

for (var i = 1; i <= 1000; i++){
    frame @i;
    primary_inchi = "";
    secondary_inchi = "";
    intermediate_smiles = "";
    monitor_smiles_a = "";
    monitor_smiles_b = ""

    // variant a, format conversion:
    primary_inchi = {thisModel}.find("inchi", "fixedH");
    monitor_smiles_a = {thisModel}.find("smiles")

    intermediate_smiles = primary_inchi.inchi("SMILES");
    secondary_inchi = intermediate_smiles.inchi("fixedH");
    monitor_smiles_b = secondary_inchi.inchi("SMILES");
    // ----

    // variant b, explicit reload/update:
    // primary_inchi = {thisModel}.find("inchi", "fixedH");
    // monitor_smiles = {thisModel}.find("smiles")

    // load_string = "$" + primary_inchi;
    // load @load_string;

    // secondary_inchi = {thisModel}.find("inchi", "fixedH");
    // ----

    if (primary_inchi == secondary_inchi);
        print "" + i + " success " + monitor_smiles_a + " " + monitor_smiles_b;
        success++;
    else;
        print "" + i + " failing " + monitor_smiles_a + " " + monitor_smiles_b;
        failing++;
    endif;}

print "\n ---- brief report ----";
print "success " + success;
print "failing " + failing;
    #+end_src


* Analyses

** Library of 100 entries

   DataWarrior was used to generate a library of 100 molecules
   (~Random_Molecules.dwar~). Smiles in the exported as text file
   (~Random_Molecules.txt~) were retrieved by
   
   #+begin_src bash :tangle no 
awk 'NR>=2 {print $2}' Random_Molecules.txt > 100_smiles.txt
   #+end_src

   and subsequently processed by

   #+begin_src bash :tangle no
python3 smiles_obsdf.py 100_smiles.txt 
   #+end_src

   to yield 43 structures with successful, and 57 structures with a failed round
   trip.  The visual comparison of the representations reveals that the current
   approach taken looses the information about the configuration of double bonds
   (E/Z) and stereogenic centers (R/S).

** Library of 5k entries

   DataWarrior suggested a library of 5k drug-like molecules
   (~Random_Molecules_5k.dwar~), exported as text file including SMILES
   (~Random_Molecules_5k.txt~, 5000 entries), or v3000 .sdf
   (~conformers_5k.sdf~, 5034 entries).

   | departing     | entries | success | failing | invariant |
   |---------------+---------+---------+---------+-----------|
   | .smi / obabel |    5000 |    2027 |    2973 |    40.54% |
   | .smi / RDKit  |    5000 |    2048 |    2952 |    40.96% |
   | .sdf / InChI  |    5043 |    1803 |    3232 |    35.75% |
   | .sdf / Jmol   |         |         |         |           |

   The first 1000k entries of the 5k library are submitted to ~Jmol_method-a~
   (commitsha ~6bbca56ef~, <2022-02-18 Fri>) with a permanent record
   (~logger_variant_A.txt~).  Some of the entries successfully pass the
   processing, a small number does not (36, or 3.6%).  A first visual inspection
   of the results suggests an extension of the Jmol script; in addition of
   reporting the SMILES for structures /prior/ to the round trip, there should
   be one with SMILES for the structurs /after/ the round trip.

   #+begin_src bash :results both code replace :format code
awk '{if ($2=="failing") print $3}' logger_variant_A.txt > intermediate_a.txt
awk '{if ($2=="failing") print $4}' logger_variant_A.txt > intermediate_b.txt
obabel -ismi intermediate_a.txt -O inter_a.svg
obabel -ismi intermediate_b.txt -O inter_b.svg
   #+end_src

   #+RESULTS:
   #+begin_src bash
   #+end_src

   There seem to be some differences, which however aren't easily spot.  If
   there is ~diff~ to compare text, is there a kind of ~diffsmi~ for SMILES?
